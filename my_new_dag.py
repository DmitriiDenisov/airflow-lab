import random

import requests
from airflow.models import DAG, Variable
import datetime as dt
from datetime import timedelta
from airflow.operators.bash import BashOperator
from airflow.operators.python import PythonOperator, ShortCircuitOperator
from airflow.operators.python_operator import BranchPythonOperator
from airflow.operators.dummy_operator import DummyOperator
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from models.DailyRate import DailyRate
from models.Stats import Stats
from models.Token import Token
from models.balances import Balance
from models.customer import Customer
from models.transactions import Transaction
from sqlalchemy import func

# Save your DB_URL into Airflow variable authorization_DB_URL, for example:
# postgresql://dmitryhse:mypassword@localhost:5432/bank_bot_db
URL_DB = Variable.get("authorization_DB_URL")
# Create engine and session:
engine = create_engine(URL_DB)
Session = sessionmaker(bind=engine)

session = Session()
Base = declarative_base()

temp_command = f"""
echo "Start Dump of DB"
pg_dump bank_bot_db > ~/bank_bot_db.dump
sed -i "1s/^/-- Automatically generated by Airflow\\n\
-- Generated on UTC:{dt.datetime.utcnow()}\\n-- Finished Dump\\n---------------------------------------------------/" ~/bank_bot_db.dump
echo "End Dump of DB"
"""

git_commit_str = """
cp ~/bank_bot_db.dump ~/bank-bot-db/bank_bot_db.dump
cd ~/bank-bot-db
git add bank_bot_db.dump
git commit -m "Automatic upload of bank_bot_db.dump from AirFlow"
git push
"""


def get_rates(**kwargs):
    aed_to_aed = 1
    response = requests.get(f'http://localhost:5004/get_rates', params={'curr_from': 'aed', 'curr_to': 'usd'})
    aed_to_usd = response.json()['rate']
    response = requests.get(f'http://localhost:5004/get_rates', params={'curr_from': 'aed', 'curr_to': 'eur'})
    aed_to_eur = response.json()['rate']
    current_date = dt.datetime.utcnow()
    dict_ = {'aed': aed_to_aed, 'usd': aed_to_usd, 'eur': aed_to_eur,
             'date': current_date}
    return dict_


def write_rates(**kwargs):
    ti = kwargs['ti']
    print(ti)
    new_daily_rate = ti.xcom_pull(key=None, task_ids='get_rates')
    print(new_daily_rate)
    new_daily_rate = DailyRate(**new_daily_rate)
    session.add_all([new_daily_rate])
    session.commit()


def get_statistics(**kwargs):
    num_custs = {'num_custs': session.query(Customer).count()}
    num_tokens = {'num_tokens': session.query(Token).count()}
    transactions_stats = session.query(
        func.count(Transaction.id).label("count_transactions"),
        func.sum(Transaction.aed_amt).label("sum_transactions_aed"),
        func.sum(Transaction.usd_amt).label("sum_transactions_usd"),
        func.sum(Transaction.eur_amt).label("sum_transactions_eur"),
        func.max(Transaction.aed_amt).label("max_transaction_aed"),
        func.max(Transaction.usd_amt).label("max_transaction_usd"),
        func.max(Transaction.eur_amt).label("max_transaction_eur")
    ).all()
    dict_trans = transactions_stats[0]._asdict()
    balances_stats = session.query(
        func.sum(Balance.aed_amt).label("sum_balances_aed"),
        func.sum(Balance.usd_amt).label("sum_balances_usd"),
        func.sum(Balance.eur_amt).label("sum_balances_eur")
    ).all()
    dict_bal = balances_stats[0]._asdict()
    current_date = {'date': dt.datetime.utcnow()}
    stats = dict(num_custs, **num_tokens, **dict_trans, **dict_bal, **current_date)
    return stats


def write_stats(**kwargs):
    ti = kwargs['ti']
    print(ti)
    stats_dict = ti.xcom_pull(key=None, task_ids='get_statistics')
    print(stats_dict)
    new_stat = Stats(**stats_dict)
    session.add_all([new_stat])
    session.commit()


def should_run(**kwargs):
    print('------------- exec dttm = {} and minute = {}'.
          format(kwargs['execution_date'], kwargs['execution_date'].minute))
    if kwargs['execution_date'].minute % 3 == 0:
        return ['CircuitOperator_1', 'CircuitOperator_3']
    elif kwargs['execution_date'].minute % 6 == 1:
        return ['CircuitOperator_2', 'CircuitOperator_4', 'CircuitOperator_5']
    else:
        return ['CircuitOperator_6', 'CircuitOperator_4']


args = {
    'owner': 'Airflow',
    'start_date': dt.datetime(2020, 9, 18),
    'depends_on_past': False,  # depends_on_past (boolean) when set to True,
    # keeps a task from getting triggered if the previous schedule for the task hasnâ€™t succeeded
    'provide_context': True
}

dag = DAG(
    dag_id='daily_rates_and_statistics',
    schedule_interval=timedelta(minutes=100),
    default_args=args,
    catchup=False,
    tags=['example']
)

bash_dummy_1 = BashOperator(
    task_id='start_currencies',
    bash_command='echo "Starting currencies thread"',
    dag=dag,
)

get_rates = PythonOperator(
    task_id='get_rates',
    python_callable=get_rates,
    dag=dag
)

write_rates = PythonOperator(
    task_id='write_rates',
    python_callable=write_rates,
    dag=dag
)

bash_dummy_2 = BashOperator(
    task_id='start_statistics',
    bash_command='echo "Starting statistics thread"',
    dag=dag,
)

get_statistics = PythonOperator(
    task_id='get_statistics',
    python_callable=get_statistics,
    dag=dag
)

write_stats = PythonOperator(
    task_id='write_stats',
    python_callable=write_stats,
    dag=dag
)

dump_db = BashOperator(task_id='dump_db', bash_command=temp_command, dag=dag)

git_commit = BashOperator(task_id='git_commit', bash_command=git_commit_str, dag=dag)

cond = BranchPythonOperator(
    task_id='condition',
    provide_context=True,
    python_callable=should_run,
    dag=dag,
)

for i in range(6):
    circuit_task = ShortCircuitOperator(
        task_id=f'CircuitOperator_{i + 1}',
        python_callable=lambda: random.choice([True, False]),
        dag=dag,
    )
    dummy_task = DummyOperator(task_id=f'dummy_task_{i}', dag=dag)
    cond >> circuit_task >> dummy_task

bash_dummy_1 >> get_rates >> write_rates >> dump_db
bash_dummy_2 >> get_statistics >> write_stats >> dump_db
dump_db >> git_commit >> cond
